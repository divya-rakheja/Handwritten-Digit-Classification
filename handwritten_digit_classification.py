# -*- coding: utf-8 -*-
"""Handwritten Digit Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HDB1We1IaZub1HXIJslKVBp35lhw0x_S

Problem 2: Learning to implement Neural Network : Gurmukhi Handwritten Digit Classification
"""

from google.colab import drive
drive.mount('/content/drive/')

#Importing required libraries

import os
import cv2
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt

# Define the path to the train and test data directories
train_dir = '/content/drive/MyDrive/Colab Notebooks/GurNum/train'
test_dir = '/content/drive/MyDrive/Colab Notebooks/GurNum/val'

# Define the image size and the number of channels
IMG_SIZE = 32
NUM_CHANNELS = 1

# Define the empty lists to store the images and their respective labels
train_images, train_labels = [], []
test_images, test_labels = [], []

# Loop through each subdirectory in the train directory and read the images
for subdir in os.listdir(train_dir):
    # Define the path to the current subdirectory
    subdir_path = os.path.join(train_dir, subdir)
    # Get the list of all image files in the current subdirectory
    files = os.listdir(subdir_path)
    # Loop through each image and read it
    for file in files:
        # Define the path to the current image
        img_path = os.path.join(subdir_path, file)
        # Read the image and resize it to the defined size
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
        # Append the image and its respective label to the lists
        train_images.append(img)
        train_labels.append(int(subdir))

# Loop through each subdirectory in the test directory and read the images
for subdir in os.listdir(test_dir):
    # Define the path to the current subdirectory
    subdir_path = os.path.join(test_dir, subdir)
    # Get the list of all image files in the current subdirectory
    files = os.listdir(subdir_path)
    # Loop through each image and read it
    for file in files:
        # Define the path to the current image
        img_path = os.path.join(subdir_path, file)
        # Read the image and resize it to the defined size
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
        # Append the image and its respective label to the lists
        test_images.append(img)
        test_labels.append(int(subdir))

# Convert the lists to numpy arrays
train_images = np.array(train_images)
train_labels = np.array(train_labels)
test_images = np.array(test_images)
test_labels = np.array(test_labels)

# Normalize the pixel values of the images
train_images = train_images.astype('float32') / 255.0
test_images = test_images.astype('float32') / 255.0

# Print the shape of the training data and target labels
print("Train Images shape:", train_images.shape) 
print("Train Labels shape:", train_labels.shape)
print("Test Images shape:", test_images.shape) 
print("Test Labels shape:", test_labels.shape)

# Display sample training images obtained from the dataset for digits 0 to 9

fig, axs = plt.subplots(2, 5, figsize=(10, 5))
axs = axs.ravel()
for i in range(10):
    idx = np.where(train_labels == i)[0][0]
    axs[i].imshow(train_images[idx].reshape(IMG_SIZE, IMG_SIZE), cmap='gray')
    axs[i].set_title(f"Label: {train_labels[idx]}")
plt.show()

"""**MODEL BUILDING**"""

# Define the architecture of the neural network
model = keras.Sequential([
    keras.layers.Flatten(input_shape=(IMG_SIZE, IMG_SIZE)),
    keras.layers.Dense(128, activation='sigmoid'),
    keras.layers.Dense(10)
])

# Compile the model
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

# Train the model
history = model.fit(train_images, train_labels, epochs=20, validation_data=(test_images, test_labels))

# Evaluate the model on the test data
test_loss, test_acc = model.evaluate(test_images, test_labels)
print('Test accuracy:', test_acc)

model.summary()

#Plot the training and validation accuracy
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()

# Plot the training and validation loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()

# Predict the class labels for the test data
y_pred_probs = model.predict(test_images)
y_pred = np.argmax(y_pred_probs, axis=1)

# Create a confusion matrix to evaluate the performance of the model
confusion_mtx = tf.math.confusion_matrix(test_labels, y_pred)

# Print the confusion matrix
print(confusion_mtx)

# Plot the confusion matrix as a heatmap
import seaborn as sns
import matplotlib.pyplot as plt
sns.heatmap(confusion_mtx, annot=True, fmt='g')
plt.xlabel('Predicted label')
plt.ylabel('True label')
plt.show()

# Print the classification report
from sklearn.metrics import classification_report
print(classification_report(test_labels, y_pred))

# Print some sample predictions

NUM_SAMPLES = 50 # Define the number of sample images to use

# Select a random subset of test images and labels for prediction
sample_indices = np.random.choice(len(test_images), size=NUM_SAMPLES, replace=False)
sample_images = test_images[sample_indices]
sample_labels = test_labels[sample_indices]

# Use the trained model to predict the labels for the sample images
sample_predictions = model.predict(sample_images)

# Display the sample images along with their true and predicted labels
fig, axs = plt.subplots(nrows=5, ncols=10, figsize=(16, 8))

for i, ax in enumerate(axs.flatten()):
    true_label = sample_labels[i]
    predicted_label = np.argmax(sample_predictions[i])

    ax.imshow(sample_images[i].reshape(IMG_SIZE, IMG_SIZE), cmap='gray')
    ax.set_title(f"True label: {true_label}\nPredicted label: {predicted_label}")
    ax.axis('off')

fig.tight_layout()
plt.show()